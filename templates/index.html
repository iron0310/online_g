<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fish Game</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      text-align: center;
      background: #000000;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: 0 auto;
      border: 2px solid #333;
    }
    #gameOverMenu, #congratulationsMenu, #startMenu {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px;
      text-align: center;
      border-radius: 10px;
    }
    #gameOverMenu button, #congratulationsMenu button, #startMenu button {
      padding: 10px 20px;
      font-size: 16px;
      margin-top: 10px;
      cursor: pointer;
    }
    #startMenu {
      display: block;
    }
  </style>
</head>
<body>
  <script src="https://cdn.socket.io/4.5.0/socket.io.min.js"></script>
  <script src="/static/game.js"></script>

  <canvas id="gameCanvas"></canvas>
  <div id="startMenu">
    <h1>Chall.io</h1>
    <button onclick="startGame()">Start</button>
    <ins class="kakao_ad_area" style="display:none;"
    data-ad-unit = "DAN-pNHdTZ22YfKJjfIO"
    data-ad-width = "160"
    data-ad-height = "600"></ins>
    <script type="text/javascript" src="//t1.daumcdn.net/kas/static/ba.min.js" async></script>
  </div>
  <div id="gameOverMenu">
    <h1>Game Over</h1>
    <p id="finalScore"></p>
    <button onclick="location.reload()">Restart</button>
  </div>
  <div id="congratulationsMenu">
    <h1>Congratulations!</h1>
    <p>You reached a size of 1500!</p>
    <button onclick="location.reload()">Restart</button>
  </div>

  <script>
    let playerId;
    let players = {};
    
    const socket = io(); // 서버와 WebSocket 연결

    socket.on('connect', () => {
      playerId = socket.id; // 서버로부터 클라이언트 ID 할당
      console.log('Connected as:', playerId);
    });

    // 이벤트 리스너는 반드시 socket 객체가 초기화된 이후에 선언
    socket.on('update_players', (serverPlayers) => {
      players = serverPlayers;
    });

    socket.on('update_foods', (serverFoods) => {
      food = serverFoods; // 서버에서 받은 음식 데이터로 동기화
    });

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    let worldSize = 9000; // 월드 크기 (정사각형)
    let gridSize = 100; // 바둑판 한 칸의 크기
    let miniMapSize = 200; // 미니맵 크기
    let playerFish = { x: worldSize / 2, y: worldSize / 2, size: 10, speed: 5 };
    let food = [];
    let score = 0;

    const camera = { x: 0, y: 0, width: canvas.width, height: canvas.height };

    const gameOverMenu = document.getElementById("gameOverMenu");
    const finalScore = document.getElementById("finalScore");
    const congratulationsMenu = document.getElementById("congratulationsMenu");
    const startMenu = document.getElementById("startMenu");

    let isGameOver = false;
    let isWon = false;
    let animationId;

    let target = null; // 마우스/터치 입력 위치

    // 캔버스 크기 조정
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      camera.width = canvas.width;
      camera.height = canvas.height;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function startGame() {
      startMenu.style.display = "none"; // 시작 창 숨기기
      gameLoop(); // 게임 시작
    }

    function createFood() {
      if (isGameOver || isWon) return;

      const y = Math.random() * worldSize;
      const size = Math.random() > 0.6 ? Math.random() * 975 + 25 : Math.random() * 20 + 5;
      const direction = Math.random() > 0.5 ? "right" : "left";
      const x = direction === "right" ? -size : worldSize + size;
      const speed = Math.random() * 3 + 1;
      food.push({ x, y, size, speed, direction });
    }

    function drawGrid() {
      ctx.strokeStyle = "#cccccc";
      ctx.lineWidth = 0.5;

      const scale = camera.width / canvas.width;

      for (let y = 0; y <= worldSize; y += gridSize) {
        const screenY = (y - camera.y) / scale;
        if (screenY >= 0 && screenY <= canvas.height) {
          ctx.beginPath();
          ctx.moveTo(0, screenY);
          ctx.lineTo(canvas.width, screenY);
          ctx.stroke();
        }
      }

      for (let x = 0; x <= worldSize; x += gridSize) {
        const screenX = (x - camera.x) / scale;
        if (screenX >= 0 && screenX <= canvas.width) {
          ctx.beginPath();
          ctx.moveTo(screenX, 0);
          ctx.lineTo(screenX, canvas.height);
          ctx.stroke();
        }
      }
    }

    function drawPlayer() {
      const scale = camera.width / canvas.width;
      const screenX = (playerFish.x - camera.x) / scale;
      const screenY = (playerFish.y - camera.y) / scale;

      ctx.beginPath();
      ctx.arc(screenX, screenY, playerFish.size / scale, 0, Math.PI * 2);
      ctx.fillStyle = "orange";
      ctx.fill();
      ctx.closePath();
    }

    function drawFood() {
      const scale = camera.width / canvas.width;
      food.forEach((f) => {  // 변수 이름 일치
        const screenX = (f.x - camera.x) / scale;
        const screenY = (f.y - camera.y) / scale;
        if (
          screenX > -f.size &&
          screenX < canvas.width + f.size &&
          screenY > -f.size &&
          screenY < canvas.height + f.size
        ) {
          ctx.beginPath();
          ctx.arc(screenX, screenY, f.size / scale, 0, Math.PI * 2);
          ctx.fillStyle = f.size > playerFish.size ? "red" : "green";
          ctx.fill();
          ctx.closePath();
        }
      });
    }

    function drawScore() {
      ctx.font = "20px Arial";
      ctx.fillStyle = "white";
      ctx.fillText(`Score: ${score}`, 10, 30);
    }

    function drawMiniMap() {
      const scale = miniMapSize / worldSize;

      const miniMapX = canvas.width - miniMapSize - 10;
      const miniMapY = canvas.height - miniMapSize - 10;

      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(miniMapX, miniMapY, miniMapSize, miniMapSize);

      food.forEach((f) => {
        const foodX = miniMapX + f.x * scale;
        const foodY = miniMapY + f.y * scale;
        ctx.fillStyle = f.size > playerFish.size ? "red" : "green";
        ctx.beginPath();
        ctx.arc(foodX, foodY, 2, 0, Math.PI * 2);
        ctx.fill();
      });

      const playerX = miniMapX + playerFish.x * scale;
      const playerY = miniMapY + playerFish.y * scale;
      ctx.fillStyle = "orange";
      ctx.beginPath();
      ctx.arc(playerX, playerY, 4, 0, Math.PI * 2);
      ctx.fill();
    }

    function moveFood() {
      if (isGameOver || isWon) return;

      food.forEach((f, index) => {
        f.x += f.direction === "right" ? f.speed : -f.speed;

        if (f.x < -f.size || f.x > worldSize + f.size) {
          food.splice(index, 1);
        }
      });
    }

    function movePlayerToTarget() {
      if (!target || isGameOver || isWon) return;

      const dx = target.x - playerFish.x;
      const dy = target.y - playerFish.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      if (distance > playerFish.speed) {
        playerFish.x += (dx / distance) * playerFish.speed;
        playerFish.y += (dy / distance) * playerFish.speed;
      } else {
        playerFish.x = target.x;
        playerFish.y = target.y;
        target = null; // 목표 지점 도달 시 정지
      }
    }


    function checkCollision() {
      food.forEach((f, index) => {
        const dx = playerFish.x - f.x;
        const dy = playerFish.y - f.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < playerFish.size + f.size) {
          if (f.size > playerFish.size) {
            endGame(); // 플레이어가 먹힘
          } else {
            score += 1;
            playerFish.size += f.size / 10;
            food.splice(index, 1); // 먹이를 제거
          }
        }
      });

      Object.keys(players).forEach((id) => {
        if (id !== playerId) {
          const otherPlayer = players[id];
          const dx = playerFish.x - otherPlayer.x;
          const dy = playerFish.y - otherPlayer.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < playerFish.size + otherPlayer.size) {
            if (playerFish.size > otherPlayer.size) {
              playerFish.size += otherPlayer.size / 2;
              score += 1;
            } else {
              endGame(); // 플레이어가 먹힘
            }
          }
        }
      });
    }

    function updateCamera() {
      const maxScale = Math.max(1, 100 / 20);
      const scaleFactor = Math.max(1, playerFish.size / 20);
      const effectiveScale = Math.min(scaleFactor, maxScale);

      camera.width = canvas.width * effectiveScale;
      camera.height = canvas.height * effectiveScale;

      camera.x = playerFish.x - camera.width / 2;
      camera.y = playerFish.y - camera.height / 2;

      if (camera.x < 0) camera.x = 0;
      if (camera.y < 0) camera.y = 0;
      if (camera.x + camera.width > worldSize) camera.x = worldSize - camera.width;
      if (camera.y + camera.height > worldSize) camera.y = worldSize - camera.height;
    }

    function endGame() {
      isGameOver = true;
      gameOverMenu.style.display = "block";
      finalScore.textContent = `Final Score: ${score}`;
      cancelAnimationFrame(animationId);
    }

    function showCongratulations() {
      isWon = true;
      congratulationsMenu.style.display = "block";
      cancelAnimationFrame(animationId);
    }

    // 터치 및 마우스 입력 처리
    canvas.addEventListener("mousedown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const scale = camera.width / canvas.width;
      target = {
        x: camera.x + (e.clientX - rect.left) * scale,
        y: camera.y + (e.clientY - rect.top) * scale,
      };
    });

    canvas.addEventListener("touchstart", (e) => {
      const rect = canvas.getBoundingClientRect();
      const scale = camera.width / canvas.width;
      const touch = e.touches[0];
      target = {
        x: camera.x + (touch.clientX - rect.left) * scale,
        y: camera.y + (touch.clientY - rect.top) * scale,
      };
    });


    window.addEventListener("keyup", (e) => {
      if (keys.hasOwnProperty(e.key)) keys[e.key] = false;
    });

    // 우클릭 방지
    canvas.addEventListener("contextmenu", (e) => {
      e.preventDefault();
    });


    // 플레이어 위치 전송
    function updatePlayerPosition() {
      if (playerId) {
        socket.emit('move_player', {
          x: playerFish.x,
          y: playerFish.y
        });
      }
    }

    // 서버로부터 플레이어 정보 업데이트
    socket.on('update_players', (updatedPlayers) => {
        Object.assign(players, updatedPlayers); // 서버에서 받은 데이터를 동기화
    });

    // 다른 플레이어 렌더링
    function drawOtherPlayers() {
        const scale = camera.width / canvas.width;

        for (const [id, player] of Object.entries(players)) {
            if (id === socket.id) continue; // 본인 플레이어는 스킵

            const screenX = (player.x - camera.x) / scale;
            const screenY = (player.y - camera.y) / scale;

            ctx.beginPath();
            ctx.arc(screenX, screenY, player.size / scale, 0, Math.PI * 2);
            ctx.fillStyle = "blue"; // 다른 플레이어는 파란색으로 표시
            ctx.fill();
            ctx.closePath();
        }
    }
    // 다른 플레이어 그리기
    Object.keys(players).forEach((id) => {
        if (id !== playerId) {
          const otherPlayer = players[id];
          ctx.beginPath();
          ctx.arc(otherPlayer.x - camera.x, otherPlayer.y - camera.y, otherPlayer.size, 0, Math.PI * 2);
          ctx.fillStyle = "blue";
          ctx.fill();
          ctx.closePath();
        }
      });
    // 매 프레임마다 호출
    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);


      drawGrid();
      drawPlayer(); // 현재 플레이어
      drawOtherPlayers(); // 다른 플레이어 렌더링
      drawScore();
      drawMiniMap();

      movePlayerToTarget();
      updateCamera();

      if (!isGameOver && !isWon) {
        updatePlayerPosition(); // 현재 위치 서버로 전송
      }

      requestAnimationFrame(gameLoop);
    }

  </script>
</body>
</html>
